#!/usr/bin/env node
!(function (t, e) {
    if ("object" == typeof exports && "object" == typeof module)
        module.exports = e();
    else if ("function" == typeof define && define.amd) define([], e);
    else {
        var r = e();
        for (var n in r) ("object" == typeof exports ? exports : t)[n] = r[n];
    }
})("undefined" != typeof window ? window : this, function () {
    return (() => {
        var t = {
                981: function (t) {
                    "undefined" != typeof window && window,
                    (t.exports = (function (t) {
                        var e = {};
                        function r(n) {
                            if (e[n]) return e[n].exports;
                            var i = (e[n] = { i: n, l: !1, exports: {} });
                            return (
                                t[n].call(i.exports, i, i.exports, r), (i.l = !0), i.exports
                            );
                        }
                        return (
                            (r.m = t),
                            (r.c = e),
                            (r.d = function (t, e, n) {
                                r.o(t, e) ||
                    Object.defineProperty(t, e, { enumerable: !0, get: n });
                            }),
                            (r.r = function (t) {
                                "undefined" != typeof Symbol &&
                    Symbol.toStringTag &&
                    Object.defineProperty(t, Symbol.toStringTag, {
                        value: "Module",
                    }),
                                Object.defineProperty(t, "__esModule", { value: !0 });
                            }),
                            (r.t = function (t, e) {
                                if ((1 & e && (t = r(t)), 8 & e)) return t;
                                if (4 & e && "object" == typeof t && t && t.__esModule)
                                    return t;
                                var n = Object.create(null);
                                if (
                                    (r.r(n),
                                    Object.defineProperty(n, "default", {
                                        enumerable: !0,
                                        value: t,
                                    }),
                                    2 & e && "string" != typeof t)
                                )
                                    for (var i in t)
                                        r.d(
                                            n,
                                            i,
                                            function (e) {
                                                return t[e];
                                            }.bind(null, i)
                                        );
                                return n;
                            }),
                            (r.n = function (t) {
                                var e =
                    t && t.__esModule
                        ? function () {
                            return t.default;
                        }
                        : function () {
                            return t;
                        };
                                return r.d(e, "a", e), e;
                            }),
                            (r.o = function (t, e) {
                                return Object.prototype.hasOwnProperty.call(t, e);
                            }),
                            (r.p = ""),
                            r((r.s = 0))
                        );
                    })([
                        function (t, e, r) {
                            "use strict";
                            r.r(e),
                            r.d(e, "Kore", function () {
                                return n;
                            }),
                            r.d(e, "SortType", function () {
                                return i;
                            });
                            class n {
                                constructor() {
                                    this.m =
                      " _-,;:!?.'\"()[]{ }@*/&#%`^+<=>|~$0123456789aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ";
                                }
                                AssertExtend() {
                                    this.IsExtended || this.t("Core needs to be extended");
                                }
                                get IsExtended() {
                                    return null != Map.prototype.All;
                                }
                                ExtendPrimitives() {
                                    let t = this;
                                    (String.prototype.Match = function (t) {
                                        return this.match(t) || [];
                                    }),
                                    (String.prototype.ReplaceAll = function (t, e, r) {
                                        if (r) {
                                            const r = t instanceof RegExp ? t : RegExp(t, "g");
                                            return this.replace(r, e);
                                        }
                                        return this.split(t).join(e);
                                    }),
                                    (String.prototype.IsEmpty = function () {
                                        return 0 === this.trim().length;
                                    }),
                                    (String.prototype.Starts = function (t) {
                                        if (this.IsEmpty() || t.IsEmpty()) return !1;
                                        let e = t.trim();
                                        return this.trim().Take(e.length) === e;
                                    }),
                                    (String.prototype.Ends = function (t) {
                                        if (this.IsEmpty() || t.IsEmpty()) return !1;
                                        let e = t.trim();
                                        return this.trim().Last(e.length) === e;
                                    }),
                                    (String.prototype.CharAt = function (e) {
                                        return (
                                            ((e > -1 && e >= this.length) ||
                            (e < 0 && -e > this.length)) &&
                            t.t("Cannot exceed length of string"),
                                            this.charAt(e + (e < 0 ? this.length : 0))
                                        );
                                    }),
                                    (String.prototype.RemoveCharAt = function (e) {
                                        let r = e + (e < 0 ? this.length : 0);
                                        return (
                                            ((e > -1 && e >= this.length) ||
                            (-e >= this.length + 1 && e < 0)) &&
                            t.t("Cannot exceed length of string"),
                                            this.Take(r) + this.Skip(r + 1)
                                        );
                                    }),
                                    (String.prototype.Remove = function (t) {
                                        return this.split(t).join("");
                                    }),
                                    (String.prototype.Without = function (t) {
                                        let e = this;
                                        return t.Each((t) => (e = e.Remove(t))), e;
                                    }),
                                    (String.prototype.Skip = function (t) {
                                        return this.substr(t);
                                    }),
                                    (String.prototype.Take = function (t) {
                                        return null == t
                                            ? 0 === this.length
                                                ? ""
                                                : this.charAt(0)
                                            : this.substr(0, t);
                                    }),
                                    (String.prototype.Last = function (t) {
                                        return null == t
                                            ? 0 === this.length
                                                ? ""
                                                : this.charAt(this.length - 1)
                                            : this.substr(this.length - t);
                                    }),
                                    (String.prototype.Omit = function (t) {
                                        return this.substr(0, this.length - t);
                                    }),
                                    (String.prototype.Repeat = function (e) {
                                        return (
                                            e < 0 && t.t("Count cannot be negative"),
                                            this.repeat(e)
                                        );
                                    }),
                                    (String.prototype.Count = function (t, e) {
                                        if (e) {
                                            const e = t instanceof RegExp ? t : RegExp(t, "g");
                                            return this.Match(e).length;
                                        }
                                        return this.split(t).length - 1;
                                    }),
                                    (String.prototype.Capitalize = function () {
                                        return this.Take(1).toUpperCase() + this.Skip(1);
                                    }),
                                    (String.prototype.CapitalizeWords = function () {
                                        return this.split(" ")
                                            .Map((t) => t.Capitalize())
                                            .join(" ");
                                    }),
                                    (String.prototype.IsAlphanumeric = function () {
                                        return (
                                            !this.IsEmpty() &&
                          null ==
                            this.split("")
                                .Map((t) => t.charCodeAt(0))
                                .When(
                                    (t) =>
                                        !(
                                            (t > 47 && t < 58) ||
                                    (t > 64 && t < 91) ||
                                    (t > 96 && t < 123)
                                        ),
                                    () => !1
                                )
                                        );
                                    }),
                                    (String.prototype.IsHexadecimal = function () {
                                        return (
                                            !this.IsEmpty() &&
                          parseInt(this.toLowerCase(), 16).toString(16) ===
                            this.toLowerCase()
                                        );
                                    }),
                                    (String.prototype.LineBreak = function () {
                                        return this.ReplaceAll("\r\n", "\n")
                                            .ReplaceAll("\r", "\n")
                                            .split("\n");
                                    }),
                                    (Number.prototype.Odd = function () {
                                        return !(!this.Int() || 0 === this) && this % 2 != 0;
                                    }),
                                    (Number.prototype.Even = function () {
                                        return !(!this.Int() || 0 === this) && this % 2 == 0;
                                    }),
                                    (Number.prototype.Int = function () {
                                        return !!t.IsNumber(this) && Math.abs(this % 1) < 1e-15;
                                    }),
                                    (Number.prototype.Finite = function () {
                                        return (
                                            !!t.IsAnyNumber(this) && !this.NaN() && isFinite(this)
                                        );
                                    }),
                                    (Number.prototype.Infinite = function () {
                                        return (
                                            !!t.IsAnyNumber(this) &&
                          !this.NaN() &&
                          !isFinite(this)
                                        );
                                    }),
                                    (Number.prototype.NaN = function () {
                                        return isNaN(this);
                                    }),
                                    (Number.prototype.RoundOff = function () {
                                        t.A(this);
                                        let e = this < 0 ? -1 : 1;
                                        return e * Math.round(e * this);
                                    }),
                                    (Number.prototype.Ceil = function () {
                                        t.A(this);
                                        let e = this < 0 ? -1 : 1;
                                        return e * Math.ceil(e * this);
                                    }),
                                    (Number.prototype.Floor = function () {
                                        t.A(this);
                                        let e = this < 0 ? -1 : 1;
                                        return e * Math.floor(e * this);
                                    }),
                                    (Number.prototype.Abs = function () {
                                        return t.A(this), Math.abs(this);
                                    }),
                                    (Number.prototype.Root = function () {
                                        return (
                                            t.A(this),
                                            this < 0 && t.t("Can't root negative"),
                                            Math.sqrt(this)
                                        );
                                    }),
                                    (Number.prototype.ToInt = function () {
                                        return t.i(this);
                                    }),
                                    (Number.prototype.ToFloat = function () {
                                        return t.f(this);
                                    }),
                                    (String.prototype.ToInt = function () {
                                        return t.i(this);
                                    }),
                                    (String.prototype.ToFloat = function () {
                                        return t.f(this);
                                    }),
                                    (Number.prototype.AtMax = function (e) {
                                        return t.A(this), Math.min(this, e);
                                    }),
                                    (Number.prototype.AtMin = function (e) {
                                        return t.A(this), Math.max(this, e);
                                    }),
                                    (Number.prototype.Clamp = function (e, r) {
                                        return (
                                            t.A(this), this.AtMax(e.AtMin(r)).AtMin(e.AtMax(r))
                                        );
                                    }),
                                    (Number.prototype.RandomTo = function (e, r) {
                                        return (
                                            t.A(this),
                                            r
                                                ? (this + Math.random() * (e - this + 1)).Floor()
                                                : (this + Math.random() * (e - this + 1)).AtMax(e)
                                        );
                                    }),
                                    (Number.prototype.RandomFor = function (t, e) {
                                        return this.RandomTo(this + t - 1, e);
                                    }),
                                    (Array.prototype.Add = function (e) {
                                        return this.concat(t.WrapArray(e));
                                    }),
                                    (Array.prototype.Flatten = function () {
                                        return 0 === this.length
                                            ? []
                                            : this.Reduce((t, e) => t.concat(e));
                                    }),
                                    (Array.prototype.Merge = function (t) {
                                        if (this.length !== t.length)
                                            throw "Array has to be same length";
                                        let e = new Map();
                                        return this.Each((r, n) => e.set(r, t[n])), e;
                                    }),
                                    (Array.prototype.AsKey = function (t) {
                                        let e = new Map();
                                        return this.Each((r, n) => e.set(r, t(r, n))), e;
                                    }),
                                    (Array.prototype.AsValue = function (t) {
                                        let e = new Map();
                                        return this.Each((r, n) => e.set(t(r, n), r)), e;
                                    }),
                                    (Array.prototype.TrimAll = function () {
                                        return this.Map((t) => t.trim());
                                    }),
                                    (Array.prototype.Sort = function (e, r) {
                                        let n = this.slice();
                                        null == r &&
                          ((e.IsNum && !t.IsNumberArray(n)) ||
                            (!t.IsStringArray(n) && !e.IsNum)) &&
                          t.t("Please provide scoring strategy"),
                                        null == r && (r = (t) => t);
                                        let i = e.Reverse ? -1 : 1;
                                        return (
                                            n.sort(
                                                (n, s) =>
                                                    (e.IsNum
                                                        ? r(n) > r(s)
                                                            ? 1
                                                            : -1
                                                        : t.lc(r(n), r(s))) * i
                                            ),
                                            n
                                        );
                                    }),
                                    (Array.prototype.Reverse = function () {
                                        let t = [];
                                        return this.Each((e) => t.push(e), !0), t;
                                    }),
                                    (Array.prototype.Has = function (e, r = !1) {
                                        return (
                                            this.When(
                                                (n) => t.Eq(n, e, r),
                                                () => !0
                                            ) || !1
                                        );
                                    }),
                                    (Array.prototype.Where = function (t) {
                                        let e = [];
                                        return (
                                            this.When(
                                                t,
                                                (t) => {
                                                    e.push(t);
                                                },
                                                !1
                                            ),
                                            e
                                        );
                                    }),
                                    (Array.prototype.Map = function (t) {
                                        let e = [];
                                        return this.Each((r, n) => e.push(t(r, n))), e;
                                    }),
                                    (Array.prototype.Each = function (t, e = !1) {
                                        if (!e) {
                                            for (let e = 0; e < this.length; e++) t(this[e], e);
                                            return this;
                                        }
                                        for (let e = this.length - 1; e >= 0; e--)
                                            t(this[e], e);
                                        return this;
                                    }),
                                    (Array.prototype.RemoveValue = function (e, r = !1) {
                                        return this.Where((n) => !t.Eq(n, e, r));
                                    }),
                                    (Array.prototype.Without = function (t, e = !1) {
                                        return this.Where((r) => !t.Has(r, e));
                                    }),
                                    (Array.prototype.WithoutIndex = function (t) {
                                        return this.Where((e, r) => !t.Has(r));
                                    }),
                                    (Array.prototype.Fill = function (t, e) {
                                        let r = this.slice();
                                        for (let n = 0; n < t; n++) r.push(e(n));
                                        return r;
                                    }),
                                    (Array.prototype.RemoveIndex = function (t) {
                                        return this.Where((e, r) => r !== t);
                                    }),
                                    (Array.prototype.Take = function (t) {
                                        return null == t
                                            ? 0 === this.length
                                                ? null
                                                : this[0]
                                            : this.slice(0, t);
                                    }),
                                    (Array.prototype.TakeWhile = function (t) {
                                        let e = [];
                                        return (
                                            this.When(
                                                t,
                                                (t) => {
                                                    e.push(t);
                                                },
                                                !0
                                            ),
                                            e
                                        );
                                    }),
                                    (Array.prototype.Skip = function (t) {
                                        return this.slice(t);
                                    }),
                                    (Array.prototype.SkipWhile = function (t) {
                                        let e = 0;
                                        return (
                                            this.When(
                                                t,
                                                () => {
                                                    e++;
                                                },
                                                !0
                                            ),
                                            this.Skip(e)
                                        );
                                    }),
                                    (Array.prototype.Omit = function (t) {
                                        return this.slice(0, -t);
                                    }),
                                    (Array.prototype.OmitWhile = function (t) {
                                        let e = 0;
                                        return (
                                            this.Reverse().When(
                                                t,
                                                () => {
                                                    e++;
                                                },
                                                !0
                                            ),
                                            this.Omit(e)
                                        );
                                    }),
                                    (Array.prototype.Last = function (t) {
                                        if (null == t)
                                            return 0 === this.length
                                                ? null
                                                : this[this.length - 1];
                                        let e = this.length - t;
                                        return this.slice(e > 0 ? e : 0);
                                    }),
                                    (Array.prototype.LastWhile = function (t) {
                                        let e = 0;
                                        return (
                                            this.Reverse().When(
                                                t,
                                                () => {
                                                    e++;
                                                },
                                                !0
                                            ),
                                            this.Last(e)
                                        );
                                    }),
                                    (Array.prototype.FirstIndexOf = function (e, r = !1) {
                                        return this.FindIndex((n) => t.Eq(n, e, r));
                                    }),
                                    (Array.prototype.Count = function (e, r = !1) {
                                        return this.Where((n) => t.Eq(n, e, r)).length;
                                    }),
                                    (Array.prototype.Indexes = function (e, r = !1) {
                                        let n = [];
                                        return (
                                            this.When(
                                                (n) => t.Eq(n, e, r),
                                                (t, e) => {
                                                    n.push(e);
                                                }
                                            ),
                                            n
                                        );
                                    }),
                                    (Array.prototype.Unique = function (t = !1) {
                                        return this.Where(
                                            (e, r) => this.FirstIndexOf(e, t) === r
                                        );
                                    }),
                                    (Array.prototype.Union = function (t, e = !1) {
                                        return this.concat(t).Unique(e);
                                    }),
                                    (Array.prototype.Intersect = function (t, e = !1) {
                                        return this.Unique(e).Where((r) => t.Has(r, e));
                                    }),
                                    (Array.prototype.Outer = function (t, e = !1) {
                                        return this.Union(t, e).Without(
                                            this.Intersect(t, e),
                                            e
                                        );
                                    }),
                                    (Array.prototype.Max = function (t = (t, e) => t) {
                                        return this.Reverse().Reduce((e, r, n) =>
                                            t(e, n - 1) > t(r, n) ? e : r
                                        );
                                    }),
                                    (Array.prototype.Min = function (t = (t, e) => t) {
                                        return this.Reverse().Reduce((e, r, n) =>
                                            t(e, n - 1) < t(r, n) ? e : r
                                        );
                                    }),
                                    (Array.prototype.Sum = function (t = (t) => t) {
                                        return this.Map((e, r) => t(e, r)).Reduce(
                                            (t, e) => t + e
                                        );
                                    }),
                                    (Array.prototype.Reduce = function (e) {
                                        if (
                                            (0 === this.length && t.t("Empty Array"),
                                            1 === this.length)
                                        )
                                            return this[0];
                                        let r = this[0];
                                        for (let t = 1; t < this.length; t++)
                                            r = e(r, this[t], t - 1);
                                        return r;
                                    }),
                                    (Array.prototype.Find = function (t) {
                                        let e = this.When(t, (t) => t);
                                        return null == e ? null : e;
                                    }),
                                    (Array.prototype.FindIndex = function (t) {
                                        let e = this.When(t, (t, e) => e);
                                        return null == e ? null : e;
                                    }),
                                    (Array.prototype.Any = function (t) {
                                        return this.When(t, () => !0) || !1;
                                    }),
                                    (Array.prototype.All = function (t) {
                                        return !this.Any((e, r) => !t(e, r));
                                    }),
                                    (Array.prototype.When = function (t, e, r = !1) {
                                        for (let n = 0; n < this.length; n++)
                                            if (t(this[n], n)) {
                                                let t = e(this[n], n);
                                                if (void 0 !== t) return t;
                                            } else if (r) break;
                                    }),
                                    (Array.prototype.Random = function () {
                                        return 0 === this.length
                                            ? null
                                            : 1 === this.length
                                                ? this[0]
                                                : this[(0).RandomFor(this.length, !0)];
                                    }),
                                    (Map.prototype.TrimValue = function () {
                                        return this.MapValue((t) => t.trim());
                                    }),
                                    (Map.prototype.SortByKey = function (t, e) {
                                        let r = this.Arr();
                                        return (
                                            (r = r.Sort(
                                                t,
                                                null == e ? (t) => t[0] : (t) => e(t[0])
                                            )),
                                            new Map(r)
                                        );
                                    }),
                                    (Map.prototype.SortByValue = function (t, e) {
                                        let r = this.Arr();
                                        return (
                                            (r = r.Sort(
                                                t,
                                                null == e ? (t) => t[1] : (t) => e(t[1])
                                            )),
                                            new Map(r)
                                        );
                                    }),
                                    (Map.prototype.Reverse = function () {
                                        return new Map(this.Arr().Reverse());
                                    }),
                                    (Map.prototype.HasKey = function (t, e) {
                                        return this.Keys().Has(t, e);
                                    }),
                                    (Map.prototype.HasValue = function (t, e) {
                                        return this.Values().Has(t, e);
                                    }),
                                    (Map.prototype.Where = function (e) {
                                        return new Map(this.Arr().Where((r) => t.M(r, e)));
                                    }),
                                    (Map.prototype.MapKey = function (t) {
                                        let e = new Map();
                                        return this.Each((r, n) => e.set(t(r, n), n)), e;
                                    }),
                                    (Map.prototype.MapValue = function (t) {
                                        let e = new Map();
                                        return this.Each((r, n) => e.set(r, t(n, r))), e;
                                    }),
                                    (Map.prototype.Map = function (t) {
                                        let e = [];
                                        return this.Each((r, n) => e.push(t(r, n))), e;
                                    }),
                                    (Map.prototype.Each = function (t) {
                                        let e = new Map();
                                        return (
                                            this.Arr().Each((r) => {
                                                t(r[0], r[1]), e.set(r[0], r[1]);
                                            }),
                                            e
                                        );
                                    }),
                                    (Map.prototype.RemoveKey = function (e, r = !1) {
                                        return this.Where((n) => !t.Eq(e, n, r));
                                    }),
                                    (Map.prototype.RemoveValue = function (e, r = !1) {
                                        return this.Where((n, i) => !t.Eq(i, e, r));
                                    }),
                                    (Map.prototype.Without = function (t, e, r = !1) {
                                        return this.Where(
                                            (n, i) => !t.Has(n, r) && !e.Has(i, r)
                                        );
                                    }),
                                    (Map.prototype.Take = function (e) {
                                        if (null == e) {
                                            let e = this.Arr().Take();
                                            return null == e ? null : t.P(e);
                                        }
                                        return new Map(this.Arr().Take(e));
                                    }),
                                    (Map.prototype.TakeWhile = function (e) {
                                        return new Map(this.Arr().TakeWhile((r) => t.M(r, e)));
                                    }),
                                    (Map.prototype.Skip = function (t) {
                                        return new Map(this.Arr().Skip(t));
                                    }),
                                    (Map.prototype.SkipWhile = function (e) {
                                        return new Map(this.Arr().SkipWhile((r) => t.M(r, e)));
                                    }),
                                    (Map.prototype.Omit = function (t) {
                                        return new Map(this.Arr().Omit(t));
                                    }),
                                    (Map.prototype.OmitWhile = function (e) {
                                        return new Map(this.Arr().OmitWhile((r) => t.M(r, e)));
                                    }),
                                    (Map.prototype.Last = function (e) {
                                        if (null == e) {
                                            let e = this.Arr().Last();
                                            return null == e ? null : t.P(e);
                                        }
                                        return new Map(this.Arr().Last(e));
                                    }),
                                    (Map.prototype.LastWhile = function (e) {
                                        return new Map(this.Arr().LastWhile((r) => t.M(r, e)));
                                    }),
                                    (Map.prototype.Arr = function () {
                                        return Array.from(this.entries());
                                    }),
                                    (Map.prototype.Keys = function () {
                                        return Array.from(this.keys());
                                    }),
                                    (Map.prototype.Values = function () {
                                        return Array.from(this.values());
                                    }),
                                    (Map.prototype.Find = function (e) {
                                        let r = this.Arr().Find((r) => t.M(r, e));
                                        return null == r ? null : t.P(r);
                                    }),
                                    (Map.prototype.Max = function (e) {
                                        return t.P(this.Arr().Max((t) => e(t[0], t[1])));
                                    }),
                                    (Map.prototype.Min = function (e) {
                                        return t.P(this.Arr().Min((t) => e(t[0], t[1])));
                                    }),
                                    (Map.prototype.Sum = function (t) {
                                        return this.Arr().Sum((e) => t(e[0], e[1]));
                                    }),
                                    (Map.prototype.Reduce = function (e) {
                                        return this.Arr()
                                            .Map((e) => t.P(e))
                                            .Reduce(e);
                                    }),
                                    (Map.prototype.Any = function (e) {
                                        return this.Arr().Any((r) => t.M(r, e));
                                    }),
                                    (Map.prototype.All = function (e) {
                                        return this.Arr().All((r) => t.M(r, e));
                                    }),
                                    (Map.prototype.AsObject = function () {
                                        let e = {};
                                        return (
                                            this.Each((r, n) => {
                                                let i = r.split(".");
                                                t.SV(e, i, n);
                                            }),
                                            e
                                        );
                                    });
                                }
                                DeepEqual(t, e) {
                                    let r = this;
                                    if (t === e) return !0;
                                    if (void 0 === t || void 0 === e) return !1;
                                    if (null === t || null === e) return !1;
                                    if (typeof t != typeof e) return !1;
                                    if (r.TC(t, e, "string")) return t + "" == e + "";
                                    if (r.TC(t, e, "number"))
                                        return isNaN(t) ? isNaN(e) : t === e;
                                    if (r.TC(t, e, "boolean")) return t === e;
                                    if (t instanceof Date) return t.valueOf() === e.valueOf();
                                    if (t.constructor !== e.constructor) return !1;
                                    if (t instanceof Function || t instanceof RegExp)
                                        return t.toString() === e.toString();
                                    if (this.IsArray(t)) {
                                        if (!this.IsArray(e)) return !1;
                                        if (t.length !== e.length) return !1;
                                    }
                                    const n = Object.keys(t);
                                    return (
                                        Object.keys(e).every((t) => -1 !== n.indexOf(t)) &&
                      n.every(function (n) {
                          return r.Eq(t[n], e[n], !0);
                      })
                                    );
                                }
                                IsAnyString(t) {
                                    return "string" == typeof t || t instanceof String;
                                }
                                IsString(t) {
                                    return !!this.IsAnyString(t) && "" !== t.trim();
                                }
                                IsAnyNumber(t) {
                                    return (
                                        null != t && ("number" == typeof t || t instanceof Number)
                                    );
                                }
                                IsNumber(t, e = !1) {
                                    if (this.IsAnyNumber(t)) return !isNaN(t) && isFinite(t);
                                    if (this.IsAnyString(t) && e) {
                                        let e = parseFloat(t);
                                        return !isNaN(e) && isFinite(e);
                                    }
                                    return !1;
                                }
                                IsArray(t) {
                                    return Array.isArray(t);
                                }
                                IsBooleanArray(t) {
                                    return this.I(t, "boolean");
                                }
                                IsNumberArray(t) {
                                    return this.I(t, "number");
                                }
                                IsStringArray(t) {
                                    return this.I(t, "string");
                                }
                                Random(t) {
                                    let e = this.m.Skip(34).split("");
                                    return [].Fill(t, () => e.Random()).join("");
                                }
                                WrapArray(t) {
                                    return this.IsArray(t) ? t : [t];
                                }
                                Eq(t, e, r) {
                                    return r ? this.DeepEqual(t, e) : t === e;
                                }
                                FlattenObject(t) {
                                    return this.FO(t);
                                }
                                FlattenClass(t, e) {
                                    return this.VO(t, "", e);
                                }
                                VO(t, e = "", r) {
                                    let n = new Map();
                                    for (let i in t)
                                        if (t.hasOwnProperty(i)) {
                                            let s = t[i];
                                            this.TO(s, "object")
                                                ? s.constructor == r
                                                    ? n.set(e + i, s)
                                                    : (n = new Map(
                                                        n
                                                            .Arr()
                                                            .Union(this.VO(s, e + i + ".", r).Arr(), !0)
                                                    ))
                                                : this.t("Needs to be object");
                                        }
                                    return n;
                                }
                                FO(t, e = "") {
                                    let r = new Map();
                                    for (let n in t)
                                        if (t.hasOwnProperty(n)) {
                                            let i = t[n];
                                            this.NO(i)
                                                ? r.set(e + n, i)
                                                : (r = new Map(
                                                    r.Arr().Union(this.FO(i, e + n + ".").Arr(), !0)
                                                ));
                                        }
                                    return r;
                                }
                                I(t, e) {
                                    return this.IsArray(t) && t.every((t) => typeof t === e);
                                }
                                NO(t) {
                                    return (
                                        this.IsArray(t) ||
                      t instanceof RegExp ||
                      t instanceof Date ||
                      !this.TO(t, "object") ||
                      this.TO(t, "function")
                                    );
                                }
                                TO(t, e) {
                                    return typeof t === e;
                                }
                                SV(t, e, r) {
                                    let n = e[0];
                                    1 === e.length
                                        ? (t[n] = r)
                                        : (this.TO(t[n], "undefined") && (t[n] = {}),
                                        this.SV(t[n], e.Skip(1), r));
                                }
                                t(t) {
                                    throw Error(t);
                                }
                                lc(t, e) {
                                    let r = "",
                                        n = "",
                                        i = 0,
                                        s = t.length === e.length;
                                    for (; r === n && i < 100; )
                                        (r = (s ? t : t.toLowerCase()).charAt(i)),
                                        (n = (s ? e : e.toLowerCase()).charAt(i)),
                                        i++;
                                    return (this.m.indexOf(r) - this.m.indexOf(n)).Clamp(-1, 1);
                                }
                                TC(t, e, r) {
                                    return typeof t === r && typeof e === r;
                                }
                                M(t, e) {
                                    return e(t[0], t[1]);
                                }
                                P(t) {
                                    return { key: t[0], value: t[1] };
                                }
                                i(t) {
                                    return (
                                        this.A(t),
                                        this.IsAnyString(t) ? parseInt(t) : Math.trunc(t)
                                    );
                                }
                                f(t) {
                                    return this.A(t), parseFloat(t);
                                }
                                A(t) {
                                    this.IsNumber(t, !0) || this.t("Invalid Number");
                                }
                            }
                            class i {
                                constructor() {
                                    (this.Ascending = { IsNum: !0, Reverse: !1 }),
                                    (this.Descending = { IsNum: !0, Reverse: !0 }),
                                    (this.AtoZ = { IsNum: !1, Reverse: !1 }),
                                    (this.ZtoA = { IsNum: !1, Reverse: !0 });
                                }
                            }
                            (i.Ascending = { IsNum: !0, Reverse: !1 }),
                            (i.Descending = { IsNum: !0, Reverse: !0 }),
                            (i.AtoZ = { IsNum: !1, Reverse: !1 }),
                            (i.ZtoA = { IsNum: !1, Reverse: !0 });
                        },
                    ]));
                },
                783: (t, e, r) => {
                    const { Argument: n } = r(717),
                        { Command: i } = r(526),
                        { CommanderError: s, InvalidArgumentError: o } = r(759),
                        { Help: a } = r(574),
                        { Option: h } = r(398);
                    ((e = t.exports = new i()).program = e),
                    (e.Argument = n),
                    (e.Command = i),
                    (e.CommanderError = s),
                    (e.Help = a),
                    (e.InvalidArgumentError = o),
                    (e.InvalidOptionArgumentError = o),
                    (e.Option = h);
                },
                717: (t, e, r) => {
                    const { InvalidArgumentError: n } = r(759);
                    (e.Argument = class {
                        constructor(t, e) {
                            switch (
                                ((this.description = e || ""),
                                (this.variadic = !1),
                                (this.parseArg = void 0),
                                (this.defaultValue = void 0),
                                (this.defaultValueDescription = void 0),
                                (this.argChoices = void 0),
                                t[0])
                            ) {
                            case "<":
                                (this.required = !0), (this._name = t.slice(1, -1));
                                break;
                            case "[":
                                (this.required = !1), (this._name = t.slice(1, -1));
                                break;
                            default:
                                (this.required = !0), (this._name = t);
                            }
                            this._name.length > 3 &&
                "..." === this._name.slice(-3) &&
                ((this.variadic = !0), (this._name = this._name.slice(0, -3)));
                        }
                        name() {
                            return this._name;
                        }
                        _concatValue(t, e) {
                            return e !== this.defaultValue && Array.isArray(e)
                                ? e.concat(t)
                                : [t];
                        }
                        default(t, e) {
                            return (
                                (this.defaultValue = t),
                                (this.defaultValueDescription = e),
                                this
                            );
                        }
                        argParser(t) {
                            return (this.parseArg = t), this;
                        }
                        choices(t) {
                            return (
                                (this.argChoices = t),
                                (this.parseArg = (e, r) => {
                                    if (!t.includes(e))
                                        throw new n(`Allowed choices are ${t.join(", ")}.`);
                                    return this.variadic ? this._concatValue(e, r) : e;
                                }),
                                this
                            );
                        }
                    }),
                    (e.humanReadableArgName = function (t) {
                        const e = t.name() + (!0 === t.variadic ? "..." : "");
                        return t.required ? "<" + e + ">" : "[" + e + "]";
                    });
                },
                526: (t, e, r) => {
                    const n = r(614).EventEmitter,
                        i = r(129),
                        s = r(622),
                        o = r(747),
                        { Argument: a, humanReadableArgName: h } = r(717),
                        { CommanderError: u } = r(759),
                        { Help: p } = r(574),
                        { Option: l, splitOptionFlags: c } = r(398);
                    class m extends n {
                        constructor(t) {
                            super(),
                            (this.commands = []),
                            (this.options = []),
                            (this.parent = null),
                            (this._allowUnknownOption = !1),
                            (this._allowExcessArguments = !0),
                            (this._args = []),
                            (this.args = []),
                            (this.rawArgs = []),
                            (this.processedArgs = []),
                            (this._scriptPath = null),
                            (this._name = t || ""),
                            (this._optionValues = {}),
                            (this._storeOptionsAsProperties = !1),
                            (this._actionHandler = null),
                            (this._executableHandler = !1),
                            (this._executableFile = null),
                            (this._defaultCommandName = null),
                            (this._exitCallback = null),
                            (this._aliases = []),
                            (this._combineFlagAndOptionalValue = !0),
                            (this._description = ""),
                            (this._argsDescription = void 0),
                            (this._enablePositionalOptions = !1),
                            (this._passThroughOptions = !1),
                            (this._lifeCycleHooks = {}),
                            (this._showHelpAfterError = !1),
                            (this._outputConfiguration = {
                                writeOut: (t) => process.stdout.write(t),
                                writeErr: (t) => process.stderr.write(t),
                                getOutHelpWidth: () =>
                                    process.stdout.isTTY ? process.stdout.columns : void 0,
                                getErrHelpWidth: () =>
                                    process.stderr.isTTY ? process.stderr.columns : void 0,
                                outputError: (t, e) => e(t),
                            }),
                            (this._hidden = !1),
                            (this._hasHelpOption = !0),
                            (this._helpFlags = "-h, --help"),
                            (this._helpDescription = "display help for command"),
                            (this._helpShortFlag = "-h"),
                            (this._helpLongFlag = "--help"),
                            (this._addImplicitHelpCommand = void 0),
                            (this._helpCommandName = "help"),
                            (this._helpCommandnameAndArgs = "help [command]"),
                            (this._helpCommandDescription = "display help for command"),
                            (this._helpConfiguration = {});
                        }
                        command(t, e, r) {
                            let n = e,
                                i = r;
                            "object" == typeof n && null !== n && ((i = n), (n = null)),
                            (i = i || {});
                            const [, s, o] = t.match(/([^ ]+) *(.*)/),
                                a = this.createCommand(s);
                            return (
                                n && (a.description(n), (a._executableHandler = !0)),
                                i.isDefault && (this._defaultCommandName = a._name),
                                (a._outputConfiguration = this._outputConfiguration),
                                (a._hidden = !(!i.noHelp && !i.hidden)),
                                (a._hasHelpOption = this._hasHelpOption),
                                (a._helpFlags = this._helpFlags),
                                (a._helpDescription = this._helpDescription),
                                (a._helpShortFlag = this._helpShortFlag),
                                (a._helpLongFlag = this._helpLongFlag),
                                (a._helpCommandName = this._helpCommandName),
                                (a._helpCommandnameAndArgs = this._helpCommandnameAndArgs),
                                (a._helpCommandDescription = this._helpCommandDescription),
                                (a._helpConfiguration = this._helpConfiguration),
                                (a._exitCallback = this._exitCallback),
                                (a._storeOptionsAsProperties = this._storeOptionsAsProperties),
                                (a._combineFlagAndOptionalValue = this._combineFlagAndOptionalValue),
                                (a._allowExcessArguments = this._allowExcessArguments),
                                (a._enablePositionalOptions = this._enablePositionalOptions),
                                (a._showHelpAfterError = this._showHelpAfterError),
                                (a._executableFile = i.executableFile || null),
                                o && a.arguments(o),
                                this.commands.push(a),
                                (a.parent = this),
                                n ? this : a
                            );
                        }
                        createCommand(t) {
                            return new m(t);
                        }
                        createHelp() {
                            return Object.assign(new p(), this.configureHelp());
                        }
                        configureHelp(t) {
                            return void 0 === t
                                ? this._helpConfiguration
                                : ((this._helpConfiguration = t), this);
                        }
                        configureOutput(t) {
                            return void 0 === t
                                ? this._outputConfiguration
                                : (Object.assign(this._outputConfiguration, t), this);
                        }
                        showHelpAfterError(t = !0) {
                            return (
                                "string" != typeof t && (t = !!t),
                                (this._showHelpAfterError = t),
                                this
                            );
                        }
                        addCommand(t, e) {
                            if (!t._name)
                                throw new Error(
                                    "Command passed to .addCommand() must have a name"
                                );
                            return (
                                (function t(e) {
                                    e.forEach((e) => {
                                        if (e._executableHandler && !e._executableFile)
                                            throw new Error(
                                                `Must specify executableFile for deeply nested executable: ${e.name()}`
                                            );
                                        t(e.commands);
                                    });
                                })(t.commands),
                                (e = e || {}).isDefault && (this._defaultCommandName = t._name),
                                (e.noHelp || e.hidden) && (t._hidden = !0),
                                this.commands.push(t),
                                (t.parent = this),
                                this
                            );
                        }
                        createArgument(t, e) {
                            return new a(t, e);
                        }
                        argument(t, e, r, n) {
                            const i = this.createArgument(t, e);
                            return (
                                "function" == typeof r
                                    ? i.default(n).argParser(r)
                                    : i.default(r),
                                this.addArgument(i),
                                this
                            );
                        }
                        arguments(t) {
                            return (
                                t.split(/ +/).forEach((t) => {
                                    this.argument(t);
                                }),
                                this
                            );
                        }
                        addArgument(t) {
                            const e = this._args.slice(-1)[0];
                            if (e && e.variadic)
                                throw new Error(
                                    `only the last argument can be variadic '${e.name()}'`
                                );
                            if (
                                t.required &&
                void 0 !== t.defaultValue &&
                void 0 === t.parseArg
                            )
                                throw new Error(
                                    `a default value for a required argument is never used: '${t.name()}'`
                                );
                            return this._args.push(t), this;
                        }
                        addHelpCommand(t, e) {
                            return (
                                !1 === t
                                    ? (this._addImplicitHelpCommand = !1)
                                    : ((this._addImplicitHelpCommand = !0),
                                    "string" == typeof t &&
                      ((this._helpCommandName = t.split(" ")[0]),
                      (this._helpCommandnameAndArgs = t)),
                                    (this._helpCommandDescription =
                      e || this._helpCommandDescription)),
                                this
                            );
                        }
                        _hasImplicitHelpCommand() {
                            return void 0 === this._addImplicitHelpCommand
                                ? this.commands.length &&
                    !this._actionHandler &&
                    !this._findCommand("help")
                                : this._addImplicitHelpCommand;
                        }
                        hook(t, e) {
                            const r = ["preAction", "postAction"];
                            if (!r.includes(t))
                                throw new Error(
                                    `Unexpected value for event passed to hook : '${t}'.\nExpecting one of '${r.join(
                                        "', '"
                                    )}'`
                                );
                            return (
                                this._lifeCycleHooks[t]
                                    ? this._lifeCycleHooks[t].push(e)
                                    : (this._lifeCycleHooks[t] = [e]),
                                this
                            );
                        }
                        exitOverride(t) {
                            return (
                                (this._exitCallback =
                  t ||
                  ((t) => {
                      if ("commander.executeSubCommandAsync" !== t.code) throw t;
                  })),
                                this
                            );
                        }
                        _exit(t, e, r) {
                            this._exitCallback && this._exitCallback(new u(t, e, r)),
                            process.exit(t);
                        }
                        action(t) {
                            return (
                                (this._actionHandler = (e) => {
                                    const r = this._args.length,
                                        n = e.slice(0, r);
                                    return (
                                        this._storeOptionsAsProperties
                                            ? (n[r] = this)
                                            : (n[r] = this.opts()),
                                        n.push(this),
                                        t.apply(this, n)
                                    );
                                }),
                                this
                            );
                        }
                        createOption(t, e) {
                            return new l(t, e);
                        }
                        addOption(t) {
                            const e = t.name(),
                                r = t.attributeName();
                            let n = t.defaultValue;
                            if (
                                t.negate ||
                t.optional ||
                t.required ||
                "boolean" == typeof n
                            ) {
                                if (t.negate) {
                                    const e = t.long.replace(/^--no-/, "--");
                                    n = !this._findOption(e) || this.getOptionValue(r);
                                }
                                void 0 !== n && this.setOptionValue(r, n);
                            }
                            return (
                                this.options.push(t),
                                this.on("option:" + e, (e) => {
                                    const i = this.getOptionValue(r);
                                    if (null !== e && t.parseArg)
                                        try {
                                            e = t.parseArg(e, void 0 === i ? n : i);
                                        } catch (r) {
                                            if ("commander.invalidArgument" === r.code) {
                                                const n = `error: option '${t.flags}' argument '${e}' is invalid. ${r.message}`;
                                                this._displayError(r.exitCode, r.code, n);
                                            }
                                            throw r;
                                        }
                                    else null !== e && t.variadic && (e = t._concatValue(e, i));
                                    "boolean" == typeof i || void 0 === i
                                        ? null == e
                                            ? this.setOptionValue(r, !t.negate && (n || !0))
                                            : this.setOptionValue(r, e)
                                        : null !== e && this.setOptionValue(r, !t.negate && e);
                                }),
                                this
                            );
                        }
                        _optionEx(t, e, r, n, i) {
                            const s = this.createOption(e, r);
                            if (
                                (s.makeOptionMandatory(!!t.mandatory), "function" == typeof n)
                            )
                                s.default(i).argParser(n);
                            else if (n instanceof RegExp) {
                                const t = n;
                                (n = (e, r) => {
                                    const n = t.exec(e);
                                    return n ? n[0] : r;
                                }),
                                s.default(i).argParser(n);
                            } else s.default(n);
                            return this.addOption(s);
                        }
                        option(t, e, r, n) {
                            return this._optionEx({}, t, e, r, n);
                        }
                        requiredOption(t, e, r, n) {
                            return this._optionEx({ mandatory: !0 }, t, e, r, n);
                        }
                        combineFlagAndOptionalValue(t = !0) {
                            return (this._combineFlagAndOptionalValue = !!t), this;
                        }
                        allowUnknownOption(t = !0) {
                            return (this._allowUnknownOption = !!t), this;
                        }
                        allowExcessArguments(t = !0) {
                            return (this._allowExcessArguments = !!t), this;
                        }
                        enablePositionalOptions(t = !0) {
                            return (this._enablePositionalOptions = !!t), this;
                        }
                        passThroughOptions(t = !0) {
                            if (
                                ((this._passThroughOptions = !!t),
                                this.parent && t && !this.parent._enablePositionalOptions)
                            )
                                throw new Error(
                                    "passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)"
                                );
                            return this;
                        }
                        storeOptionsAsProperties(t = !0) {
                            if (((this._storeOptionsAsProperties = !!t), this.options.length))
                                throw new Error(
                                    "call .storeOptionsAsProperties() before adding options"
                                );
                            return this;
                        }
                        getOptionValue(t) {
                            return this._storeOptionsAsProperties
                                ? this[t]
                                : this._optionValues[t];
                        }
                        setOptionValue(t, e) {
                            return (
                                this._storeOptionsAsProperties
                                    ? (this[t] = e)
                                    : (this._optionValues[t] = e),
                                this
                            );
                        }
                        _prepareUserArgs(t, e) {
                            if (void 0 !== t && !Array.isArray(t))
                                throw new Error(
                                    "first parameter to parse must be array or undefined"
                                );
                            let n;
                            switch (
                                ((e = e || {}),
                                void 0 === t &&
                  ((t = process.argv),
                  process.versions &&
                    process.versions.electron &&
                    (e.from = "electron")),
                                (this.rawArgs = t.slice()),
                                e.from)
                            ) {
                            case void 0:
                            case "node":
                                (this._scriptPath = t[1]), (n = t.slice(2));
                                break;
                            case "electron":
                                process.defaultApp
                                    ? ((this._scriptPath = t[1]), (n = t.slice(2)))
                                    : (n = t.slice(1));
                                break;
                            case "user":
                                n = t.slice(0);
                                break;
                            default:
                                throw new Error(
                                    `unexpected parse option { from: '${e.from}' }`
                                );
                            }
                            return (
                                !this._scriptPath &&
                  r.c[r.s] &&
                  (this._scriptPath = r.c[r.s].filename),
                                (this._name =
                  this._name ||
                  (this._scriptPath &&
                    s.basename(this._scriptPath, s.extname(this._scriptPath)))),
                                n
                            );
                        }
                        parse(t, e) {
                            const r = this._prepareUserArgs(t, e);
                            return this._parseCommand([], r), this;
                        }
                        async parseAsync(t, e) {
                            const r = this._prepareUserArgs(t, e);
                            return await this._parseCommand([], r), this;
                        }
                        _executeSubCommand(t, e) {
                            e = e.slice();
                            let n = !1;
                            const a = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
                            this._checkForMissingMandatoryOptions();
                            let h,
                                p = this._scriptPath;
                            !p && r.c[r.s] && (p = r.c[r.s].filename);
                            try {
                                const t = o.realpathSync(p);
                                h = s.dirname(t);
                            } catch (t) {
                                h = ".";
                            }
                            let l = s.basename(p, s.extname(p)) + "-" + t._name;
                            t._executableFile && (l = t._executableFile);
                            const c = s.join(h, l);
                            let m;
                            o.existsSync(c)
                                ? (l = c)
                                : a.forEach((t) => {
                                    o.existsSync(`${c}${t}`) && (l = `${c}${t}`);
                                }),
                            (n = a.includes(s.extname(l))),
                            "win32" !== process.platform
                                ? n
                                    ? (e.unshift(l),
                                    (e = f(process.execArgv).concat(e)),
                                    (m = i.spawn(process.argv[0], e, { stdio: "inherit" })))
                                    : (m = i.spawn(l, e, { stdio: "inherit" }))
                                : (e.unshift(l),
                                (e = f(process.execArgv).concat(e)),
                                (m = i.spawn(process.execPath, e, { stdio: "inherit" })));
                            ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"].forEach(
                                (t) => {
                                    process.on(t, () => {
                                        !1 === m.killed && null === m.exitCode && m.kill(t);
                                    });
                                }
                            );
                            const d = this._exitCallback;
                            d
                                ? m.on("close", () => {
                                    d(
                                        new u(
                                            process.exitCode || 0,
                                            "commander.executeSubCommandAsync",
                                            "(close)"
                                        )
                                    );
                                })
                                : m.on("close", process.exit.bind(process)),
                            m.on("error", (e) => {
                                if ("ENOENT" === e.code) {
                                    const e = `'${l}' does not exist\n - if '${t._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name`;
                                    throw new Error(e);
                                }
                                if ("EACCES" === e.code)
                                    throw new Error(`'${l}' not executable`);
                                if (d) {
                                    const t = new u(
                                        1,
                                        "commander.executeSubCommandAsync",
                                        "(error)"
                                    );
                                    (t.nestedError = e), d(t);
                                } else process.exit(1);
                            }),
                            (this.runningCommand = m);
                        }
                        _dispatchSubcommand(t, e, r) {
                            const n = this._findCommand(t);
                            if ((n || this.help({ error: !0 }), !n._executableHandler))
                                return n._parseCommand(e, r);
                            this._executeSubCommand(n, e.concat(r));
                        }
                        _checkNumberOfArguments() {
                            this._args.forEach((t, e) => {
                                t.required &&
                  null == this.args[e] &&
                  this.missingArgument(t.name());
                            }),
                            (this._args.length > 0 &&
                  this._args[this._args.length - 1].variadic) ||
                  (this.args.length > this._args.length &&
                    this._excessArguments(this.args));
                        }
                        _processArguments() {
                            const t = (t, e, r) => {
                                let n = e;
                                if (null !== e && t.parseArg)
                                    try {
                                        n = t.parseArg(e, r);
                                    } catch (r) {
                                        if ("commander.invalidArgument" === r.code) {
                                            const n = `error: command-argument value '${e}' is invalid for argument '${t.name()}'. ${
                                                r.message
                                            }`;
                                            this._displayError(r.exitCode, r.code, n);
                                        }
                                        throw r;
                                    }
                                return n;
                            };
                            this._checkNumberOfArguments();
                            const e = [];
                            this._args.forEach((r, n) => {
                                let i = r.defaultValue;
                                r.variadic
                                    ? n < this.args.length
                                        ? ((i = this.args.slice(n)),
                                        r.parseArg &&
                        (i = i.reduce((e, n) => t(r, n, e), r.defaultValue)))
                                        : void 0 === i && (i = [])
                                    : n < this.args.length &&
                    ((i = this.args[n]),
                    r.parseArg && (i = t(r, i, r.defaultValue))),
                                (e[n] = i);
                            }),
                            (this.processedArgs = e);
                        }
                        _chainOrCall(t, e) {
                            return t && t.then && "function" == typeof t.then
                                ? t.then(() => e())
                                : e();
                        }
                        _chainOrCallHooks(t, e) {
                            let r = t;
                            const n = [];
                            return (
                                (function (t) {
                                    const e = [];
                                    for (let r = t; r; r = r.parent) e.push(r);
                                    return e;
                                })(this)
                                    .reverse()
                                    .filter((t) => void 0 !== t._lifeCycleHooks[e])
                                    .forEach((t) => {
                                        t._lifeCycleHooks[e].forEach((e) => {
                                            n.push({ hookedCommand: t, callback: e });
                                        });
                                    }),
                                "postAction" === e && n.reverse(),
                                n.forEach((t) => {
                                    r = this._chainOrCall(r, () =>
                                        t.callback(t.hookedCommand, this)
                                    );
                                }),
                                r
                            );
                        }
                        _parseCommand(t, e) {
                            const r = this.parseOptions(e);
                            if (
                                ((t = t.concat(r.operands)),
                                (e = r.unknown),
                                (this.args = t.concat(e)),
                                t && this._findCommand(t[0]))
                            )
                                return this._dispatchSubcommand(t[0], t.slice(1), e);
                            if (
                                this._hasImplicitHelpCommand() &&
                t[0] === this._helpCommandName
                            )
                                return (
                                    1 === t.length && this.help(),
                                    this._dispatchSubcommand(t[1], [], [this._helpLongFlag])
                                );
                            if (this._defaultCommandName)
                                return (
                                    d(this, e),
                                    this._dispatchSubcommand(this._defaultCommandName, t, e)
                                );
                            !this.commands.length ||
                0 !== this.args.length ||
                this._actionHandler ||
                this._defaultCommandName ||
                this.help({ error: !0 }),
                            d(this, r.unknown),
                            this._checkForMissingMandatoryOptions();
                            const n = () => {
                                    r.unknown.length > 0 && this.unknownOption(r.unknown[0]);
                                },
                                i = `command:${this.name()}`;
                            if (this._actionHandler) {
                                let r;
                                return (
                                    n(),
                                    this._processArguments(),
                                    (r = this._chainOrCallHooks(r, "preAction")),
                                    (r = this._chainOrCall(r, () =>
                                        this._actionHandler(this.processedArgs)
                                    )),
                                    this.parent && this.parent.emit(i, t, e),
                                    (r = this._chainOrCallHooks(r, "postAction")),
                                    r
                                );
                            }
                            if (this.parent && this.parent.listenerCount(i))
                                n(), this._processArguments(), this.parent.emit(i, t, e);
                            else if (t.length) {
                                if (this._findCommand("*"))
                                    return this._dispatchSubcommand("*", t, e);
                                this.listenerCount("command:*")
                                    ? this.emit("command:*", t, e)
                                    : this.commands.length
                                        ? this.unknownCommand()
                                        : (n(), this._processArguments());
                            } else
                                this.commands.length
                                    ? this.help({ error: !0 })
                                    : (n(), this._processArguments());
                        }
                        _findCommand(t) {
                            if (t)
                                return this.commands.find(
                                    (e) => e._name === t || e._aliases.includes(t)
                                );
                        }
                        _findOption(t) {
                            return this.options.find((e) => e.is(t));
                        }
                        _checkForMissingMandatoryOptions() {
                            for (let t = this; t; t = t.parent)
                                t.options.forEach((e) => {
                                    e.mandatory &&
                    void 0 === t.getOptionValue(e.attributeName()) &&
                    t.missingMandatoryOptionValue(e);
                                });
                        }
                        parseOptions(t) {
                            const e = [],
                                r = [];
                            let n = e;
                            const i = t.slice();
                            function s(t) {
                                return t.length > 1 && "-" === t[0];
                            }
                            let o = null;
                            for (; i.length; ) {
                                const t = i.shift();
                                if ("--" === t) {
                                    n === r && n.push(t), n.push(...i);
                                    break;
                                }
                                if (!o || s(t)) {
                                    if (((o = null), s(t))) {
                                        const e = this._findOption(t);
                                        if (e) {
                                            if (e.required) {
                                                const t = i.shift();
                                                void 0 === t && this.optionMissingArgument(e),
                                                this.emit(`option:${e.name()}`, t);
                                            } else if (e.optional) {
                                                let t = null;
                                                i.length > 0 && !s(i[0]) && (t = i.shift()),
                                                this.emit(`option:${e.name()}`, t);
                                            } else this.emit(`option:${e.name()}`);
                                            o = e.variadic ? e : null;
                                            continue;
                                        }
                                    }
                                    if (t.length > 2 && "-" === t[0] && "-" !== t[1]) {
                                        const e = this._findOption(`-${t[1]}`);
                                        if (e) {
                                            e.required ||
                      (e.optional && this._combineFlagAndOptionalValue)
                                                ? this.emit(`option:${e.name()}`, t.slice(2))
                                                : (this.emit(`option:${e.name()}`),
                                                i.unshift(`-${t.slice(2)}`));
                                            continue;
                                        }
                                    }
                                    if (/^--[^=]+=/.test(t)) {
                                        const e = t.indexOf("="),
                                            r = this._findOption(t.slice(0, e));
                                        if (r && (r.required || r.optional)) {
                                            this.emit(`option:${r.name()}`, t.slice(e + 1));
                                            continue;
                                        }
                                    }
                                    if (
                                        (s(t) && (n = r),
                                        (this._enablePositionalOptions ||
                      this._passThroughOptions) &&
                      0 === e.length &&
                      0 === r.length)
                                    ) {
                                        if (this._findCommand(t)) {
                                            e.push(t), i.length > 0 && r.push(...i);
                                            break;
                                        }
                                        if (
                                            t === this._helpCommandName &&
                      this._hasImplicitHelpCommand()
                                        ) {
                                            e.push(t), i.length > 0 && e.push(...i);
                                            break;
                                        }
                                        if (this._defaultCommandName) {
                                            r.push(t), i.length > 0 && r.push(...i);
                                            break;
                                        }
                                    }
                                    if (this._passThroughOptions) {
                                        n.push(t), i.length > 0 && n.push(...i);
                                        break;
                                    }
                                    n.push(t);
                                } else this.emit(`option:${o.name()}`, t);
                            }
                            return { operands: e, unknown: r };
                        }
                        opts() {
                            if (this._storeOptionsAsProperties) {
                                const t = {},
                                    e = this.options.length;
                                for (let r = 0; r < e; r++) {
                                    const e = this.options[r].attributeName();
                                    t[e] =
                    e === this._versionOptionName ? this._version : this[e];
                                }
                                return t;
                            }
                            return this._optionValues;
                        }
                        _displayError(t, e, r) {
                            this._outputConfiguration.outputError(
                                `${r}\n`,
                                this._outputConfiguration.writeErr
                            ),
                            "string" == typeof this._showHelpAfterError
                                ? this._outputConfiguration.writeErr(
                                    `${this._showHelpAfterError}\n`
                                )
                                : this._showHelpAfterError &&
                    (this._outputConfiguration.writeErr("\n"),
                    this.outputHelp({ error: !0 })),
                            this._exit(t, e, r);
                        }
                        missingArgument(t) {
                            const e = `error: missing required argument '${t}'`;
                            this._displayError(1, "commander.missingArgument", e);
                        }
                        optionMissingArgument(t) {
                            const e = `error: option '${t.flags}' argument missing`;
                            this._displayError(1, "commander.optionMissingArgument", e);
                        }
                        missingMandatoryOptionValue(t) {
                            const e = `error: required option '${t.flags}' not specified`;
                            this._displayError(1, "commander.missingMandatoryOptionValue", e);
                        }
                        unknownOption(t) {
                            if (this._allowUnknownOption) return;
                            const e = `error: unknown option '${t}'`;
                            this._displayError(1, "commander.unknownOption", e);
                        }
                        _excessArguments(t) {
                            if (this._allowExcessArguments) return;
                            const e = this._args.length,
                                r = 1 === e ? "" : "s",
                                n = `error: too many arguments${
                                    this.parent ? ` for '${this.name()}'` : ""
                                }. Expected ${e} argument${r} but got ${t.length}.`;
                            this._displayError(1, "commander.excessArguments", n);
                        }
                        unknownCommand() {
                            const t = `error: unknown command '${this.args[0]}'`;
                            this._displayError(1, "commander.unknownCommand", t);
                        }
                        version(t, e, r) {
                            if (void 0 === t) return this._version;
                            (this._version = t),
                            (e = e || "-V, --version"),
                            (r = r || "output the version number");
                            const n = this.createOption(e, r);
                            return (
                                (this._versionOptionName = n.attributeName()),
                                this.options.push(n),
                                this.on("option:" + n.name(), () => {
                                    this._outputConfiguration.writeOut(`${t}\n`),
                                    this._exit(0, "commander.version", t);
                                }),
                                this
                            );
                        }
                        description(t, e) {
                            return void 0 === t && void 0 === e
                                ? this._description
                                : ((this._description = t),
                                e && (this._argsDescription = e),
                                this);
                        }
                        alias(t) {
                            if (void 0 === t) return this._aliases[0];
                            let e = this;
                            if (
                                (0 !== this.commands.length &&
                  this.commands[this.commands.length - 1]._executableHandler &&
                  (e = this.commands[this.commands.length - 1]),
                                t === e._name)
                            )
                                throw new Error("Command alias can't be the same as its name");
                            return e._aliases.push(t), this;
                        }
                        aliases(t) {
                            return void 0 === t
                                ? this._aliases
                                : (t.forEach((t) => this.alias(t)), this);
                        }
                        usage(t) {
                            if (void 0 === t) {
                                if (this._usage) return this._usage;
                                const t = this._args.map((t) => h(t));
                                return []
                                    .concat(
                                        this.options.length || this._hasHelpOption
                                            ? "[options]"
                                            : [],
                                        this.commands.length ? "[command]" : [],
                                        this._args.length ? t : []
                                    )
                                    .join(" ");
                            }
                            return (this._usage = t), this;
                        }
                        name(t) {
                            return void 0 === t ? this._name : ((this._name = t), this);
                        }
                        helpInformation(t) {
                            const e = this.createHelp();
                            return (
                                void 0 === e.helpWidth &&
                  (e.helpWidth =
                    t && t.error
                        ? this._outputConfiguration.getErrHelpWidth()
                        : this._outputConfiguration.getOutHelpWidth()),
                                e.formatHelp(this, e)
                            );
                        }
                        _getHelpContext(t) {
                            const e = { error: !!(t = t || {}).error };
                            let r;
                            return (
                                (r = e.error
                                    ? (t) => this._outputConfiguration.writeErr(t)
                                    : (t) => this._outputConfiguration.writeOut(t)),
                                (e.write = t.write || r),
                                (e.command = this),
                                e
                            );
                        }
                        outputHelp(t) {
                            let e;
                            "function" == typeof t && ((e = t), (t = void 0));
                            const r = this._getHelpContext(t),
                                n = [];
                            let i = this;
                            for (; i; ) n.push(i), (i = i.parent);
                            n
                                .slice()
                                .reverse()
                                .forEach((t) => t.emit("beforeAllHelp", r)),
                            this.emit("beforeHelp", r);
                            let s = this.helpInformation(r);
                            if (
                                e &&
                ((s = e(s)), "string" != typeof s && !Buffer.isBuffer(s))
                            )
                                throw new Error(
                                    "outputHelp callback must return a string or a Buffer"
                                );
                            r.write(s),
                            this.emit(this._helpLongFlag),
                            this.emit("afterHelp", r),
                            n.forEach((t) => t.emit("afterAllHelp", r));
                        }
                        helpOption(t, e) {
                            if ("boolean" == typeof t) return (this._hasHelpOption = t), this;
                            (this._helpFlags = t || this._helpFlags),
                            (this._helpDescription = e || this._helpDescription);
                            const r = c(this._helpFlags);
                            return (
                                (this._helpShortFlag = r.shortFlag),
                                (this._helpLongFlag = r.longFlag),
                                this
                            );
                        }
                        help(t) {
                            this.outputHelp(t);
                            let e = process.exitCode || 0;
                            0 === e && t && "function" != typeof t && t.error && (e = 1),
                            this._exit(e, "commander.help", "(outputHelp)");
                        }
                        addHelpText(t, e) {
                            const r = ["beforeAll", "before", "after", "afterAll"];
                            if (!r.includes(t))
                                throw new Error(
                                    `Unexpected value for position to addHelpText.\nExpecting one of '${r.join(
                                        "', '"
                                    )}'`
                                );
                            const n = `${t}Help`;
                            return (
                                this.on(n, (t) => {
                                    let r;
                                    (r =
                    "function" == typeof e
                        ? e({ error: t.error, command: t.command })
                        : e),
                                    r && t.write(`${r}\n`);
                                }),
                                this
                            );
                        }
                    }
                    function d(t, e) {
                        t._hasHelpOption &&
              e.find((e) => e === t._helpLongFlag || e === t._helpShortFlag) &&
              (t.outputHelp(),
              t._exit(0, "commander.helpDisplayed", "(outputHelp)"));
                    }
                    function f(t) {
                        return t.map((t) => {
                            if (!t.startsWith("--inspect")) return t;
                            let e,
                                r,
                                n = "127.0.0.1",
                                i = "9229";
                            return (
                                null !== (r = t.match(/^(--inspect(-brk)?)$/))
                                    ? (e = r[1])
                                    : null !== (r = t.match(/^(--inspect(-brk|-port)?)=([^:]+)$/))
                                        ? ((e = r[1]), /^\d+$/.test(r[3]) ? (i = r[3]) : (n = r[3]))
                                        : null !==
                      (r = t.match(
                          /^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/
                      )) && ((e = r[1]), (n = r[3]), (i = r[4])),
                                e && "0" !== i ? `${e}=${n}:${parseInt(i) + 1}` : t
                            );
                        });
                    }
                    e.Command = m;
                },
                759: (t, e) => {
                    class r extends Error {
                        constructor(t, e, r) {
                            super(r),
                            Error.captureStackTrace(this, this.constructor),
                            (this.name = this.constructor.name),
                            (this.code = e),
                            (this.exitCode = t),
                            (this.nestedError = void 0);
                        }
                    }
                    (e.CommanderError = r),
                    (e.InvalidArgumentError = class extends r {
                        constructor(t) {
                            super(1, "commander.invalidArgument", t),
                            Error.captureStackTrace(this, this.constructor),
                            (this.name = this.constructor.name);
                        }
                    });
                },
                574: (t, e, r) => {
                    const { humanReadableArgName: n } = r(717);
                    e.Help = class {
                        constructor() {
                            (this.helpWidth = void 0),
                            (this.sortSubcommands = !1),
                            (this.sortOptions = !1);
                        }
                        visibleCommands(t) {
                            const e = t.commands.filter((t) => !t._hidden);
                            if (t._hasImplicitHelpCommand()) {
                                const [, r, n] = t._helpCommandnameAndArgs.match(
                                        /([^ ]+) *(.*)/
                                    ),
                                    i = t.createCommand(r).helpOption(!1);
                                i.description(t._helpCommandDescription),
                                n && i.arguments(n),
                                e.push(i);
                            }
                            return (
                                this.sortSubcommands &&
                  e.sort((t, e) => t.name().localeCompare(e.name())),
                                e
                            );
                        }
                        visibleOptions(t) {
                            const e = t.options.filter((t) => !t.hidden),
                                r =
                  t._hasHelpOption &&
                  t._helpShortFlag &&
                  !t._findOption(t._helpShortFlag),
                                n = t._hasHelpOption && !t._findOption(t._helpLongFlag);
                            if (r || n) {
                                let i;
                                (i = r
                                    ? n
                                        ? t.createOption(t._helpFlags, t._helpDescription)
                                        : t.createOption(t._helpShortFlag, t._helpDescription)
                                    : t.createOption(t._helpLongFlag, t._helpDescription)),
                                e.push(i);
                            }
                            if (this.sortOptions) {
                                const t = (t) =>
                                    t.short
                                        ? t.short.replace(/^-/, "")
                                        : t.long.replace(/^--/, "");
                                e.sort((e, r) => t(e).localeCompare(t(r)));
                            }
                            return e;
                        }
                        visibleArguments(t) {
                            return (
                                t._argsDescription &&
                  t._args.forEach((e) => {
                      e.description =
                      e.description || t._argsDescription[e.name()] || "";
                  }),
                                t._args.find((t) => t.description) ? t._args : []
                            );
                        }
                        subcommandTerm(t) {
                            const e = t._args.map((t) => n(t)).join(" ");
                            return (
                                t._name +
                (t._aliases[0] ? "|" + t._aliases[0] : "") +
                (t.options.length ? " [options]" : "") +
                (e ? " " + e : "")
                            );
                        }
                        optionTerm(t) {
                            return t.flags;
                        }
                        argumentTerm(t) {
                            return t.name();
                        }
                        longestSubcommandTermLength(t, e) {
                            return e
                                .visibleCommands(t)
                                .reduce((t, r) => Math.max(t, e.subcommandTerm(r).length), 0);
                        }
                        longestOptionTermLength(t, e) {
                            return e
                                .visibleOptions(t)
                                .reduce((t, r) => Math.max(t, e.optionTerm(r).length), 0);
                        }
                        longestArgumentTermLength(t, e) {
                            return e
                                .visibleArguments(t)
                                .reduce((t, r) => Math.max(t, e.argumentTerm(r).length), 0);
                        }
                        commandUsage(t) {
                            let e = t._name;
                            t._aliases[0] && (e = e + "|" + t._aliases[0]);
                            let r = "";
                            for (let e = t.parent; e; e = e.parent) r = e.name() + " " + r;
                            return r + e + " " + t.usage();
                        }
                        commandDescription(t) {
                            return t.description();
                        }
                        subcommandDescription(t) {
                            return t.description();
                        }
                        optionDescription(t) {
                            if (t.negate) return t.description;
                            const e = [];
                            return (
                                t.argChoices &&
                  e.push(
                      `choices: ${t.argChoices
                          .map((t) => JSON.stringify(t))
                          .join(", ")}`
                  ),
                                void 0 !== t.defaultValue &&
                  e.push(
                      `default: ${
                          t.defaultValueDescription ||
                      JSON.stringify(t.defaultValue)
                      }`
                  ),
                                e.length > 0
                                    ? `${t.description} (${e.join(", ")})`
                                    : t.description
                            );
                        }
                        argumentDescription(t) {
                            const e = [];
                            if (
                                (t.argChoices &&
                  e.push(
                      `choices: ${t.argChoices
                          .map((t) => JSON.stringify(t))
                          .join(", ")}`
                  ),
                                void 0 !== t.defaultValue &&
                  e.push(
                      `default: ${
                          t.defaultValueDescription ||
                      JSON.stringify(t.defaultValue)
                      }`
                  ),
                                e.length > 0)
                            ) {
                                const r = `(${e.join(", ")})`;
                                return t.description ? `${t.description} ${r}` : r;
                            }
                            return t.description;
                        }
                        formatHelp(t, e) {
                            const r = e.padWidth(t, e),
                                n = e.helpWidth || 80;
                            function i(t, i) {
                                if (i) {
                                    const s = `${t.padEnd(r + 2)}${i}`;
                                    return e.wrap(s, n - 2, r + 2);
                                }
                                return t;
                            }
                            function s(t) {
                                return t.join("\n").replace(/^/gm, " ".repeat(2));
                            }
                            let o = [`Usage: ${e.commandUsage(t)}`, ""];
                            const a = e.commandDescription(t);
                            a.length > 0 && (o = o.concat([a, ""]));
                            const h = e
                                .visibleArguments(t)
                                .map((t) => i(e.argumentTerm(t), e.argumentDescription(t)));
                            h.length > 0 && (o = o.concat(["Arguments:", s(h), ""]));
                            const u = e
                                .visibleOptions(t)
                                .map((t) => i(e.optionTerm(t), e.optionDescription(t)));
                            u.length > 0 && (o = o.concat(["Options:", s(u), ""]));
                            const p = e
                                .visibleCommands(t)
                                .map((t) => i(e.subcommandTerm(t), e.subcommandDescription(t)));
                            return (
                                p.length > 0 && (o = o.concat(["Commands:", s(p), ""])),
                                o.join("\n")
                            );
                        }
                        padWidth(t, e) {
                            return Math.max(
                                e.longestOptionTermLength(t, e),
                                e.longestSubcommandTermLength(t, e),
                                e.longestArgumentTermLength(t, e)
                            );
                        }
                        wrap(t, e, r, n = 40) {
                            if (t.match(/[\n]\s+/)) return t;
                            const i = e - r;
                            if (i < n) return t;
                            const s = t.substr(0, r),
                                o = t.substr(r),
                                a = " ".repeat(r),
                                h = new RegExp(
                                    ".{1," + (i - 1) + "}([\\s​]|$)|[^\\s​]+?([\\s​]|$)",
                                    "g"
                                );
                            return (
                                s +
                (o.match(h) || [])
                    .map(
                        (t, e) => (
                            "\n" === t.slice(-1) && (t = t.slice(0, t.length - 1)),
                            (e > 0 ? a : "") + t.trimRight()
                        )
                    )
                    .join("\n")
                            );
                        }
                    };
                },
                398: (t, e, r) => {
                    const { InvalidArgumentError: n } = r(759);
                    function i(t) {
                        let e, r;
                        const n = t.split(/[ |,]+/);
                        return (
                            n.length > 1 && !/^[[<]/.test(n[1]) && (e = n.shift()),
                            (r = n.shift()),
                            !e && /^-[^-]$/.test(r) && ((e = r), (r = void 0)),
                            { shortFlag: e, longFlag: r }
                        );
                    }
                    (e.Option = class {
                        constructor(t, e) {
                            (this.flags = t),
                            (this.description = e || ""),
                            (this.required = t.includes("<")),
                            (this.optional = t.includes("[")),
                            (this.variadic = /\w\.\.\.[>\]]$/.test(t)),
                            (this.mandatory = !1);
                            const r = i(t);
                            (this.short = r.shortFlag),
                            (this.long = r.longFlag),
                            (this.negate = !1),
                            this.long && (this.negate = this.long.startsWith("--no-")),
                            (this.defaultValue = void 0),
                            (this.defaultValueDescription = void 0),
                            (this.parseArg = void 0),
                            (this.hidden = !1),
                            (this.argChoices = void 0);
                        }
                        default(t, e) {
                            return (
                                (this.defaultValue = t),
                                (this.defaultValueDescription = e),
                                this
                            );
                        }
                        argParser(t) {
                            return (this.parseArg = t), this;
                        }
                        makeOptionMandatory(t = !0) {
                            return (this.mandatory = !!t), this;
                        }
                        hideHelp(t = !0) {
                            return (this.hidden = !!t), this;
                        }
                        _concatValue(t, e) {
                            return e !== this.defaultValue && Array.isArray(e)
                                ? e.concat(t)
                                : [t];
                        }
                        choices(t) {
                            return (
                                (this.argChoices = t),
                                (this.parseArg = (e, r) => {
                                    if (!t.includes(e))
                                        throw new n(`Allowed choices are ${t.join(", ")}.`);
                                    return this.variadic ? this._concatValue(e, r) : e;
                                }),
                                this
                            );
                        }
                        name() {
                            return this.long
                                ? this.long.replace(/^--/, "")
                                : this.short.replace(/^-/, "");
                        }
                        attributeName() {
                            return this.name()
                                .replace(/^no-/, "")
                                .split("-")
                                .reduce((t, e) => t + e[0].toUpperCase() + e.slice(1));
                        }
                        is(t) {
                            return this.short === t || this.long === t;
                        }
                    }),
                    (e.splitOptionFlags = i);
                },
                227: (t, e, r) => {
                    "use strict";
                    r.r(e);
                    var n = r(981),
                        i = r(783);
                    new n.Kore().ExtendPrimitives(),
                    i.program.on("command:*", function () {
                        console.error(
                            "Invalid command: %s\nSee --help for a list of available commands.",
                            i.program.args.join(" ")
                        ),
                        process.exit(1);
                    }),
                    i.program
                        .name("Semantic Generator")
                        .version("0.0.1")
                        .description(
                            "Semantic Release configuration generator for conventional commits"
                        ),
                    i.program.parse(process.argv);
                },
                129: (t) => {
                    "use strict";
                    t.exports = require("child_process");
                },
                614: (t) => {
                    "use strict";
                    t.exports = require("events");
                },
                747: (t) => {
                    "use strict";
                    t.exports = require("fs");
                },
                622: (t) => {
                    "use strict";
                    t.exports = require("path");
                },
            },
            e = {};
        function r(n) {
            var i = e[n];
            if (void 0 !== i) return i.exports;
            var s = (e[n] = { exports: {} });
            return t[n].call(s.exports, s, s.exports, r), s.exports;
        }
        return (
            (r.c = e),
            (r.n = (t) => {
                var e = t && t.__esModule ? () => t.default : () => t;
                return r.d(e, { a: e }), e;
            }),
            (r.d = (t, e) => {
                for (var n in e)
                    r.o(e, n) &&
            !r.o(t, n) &&
            Object.defineProperty(t, n, { enumerable: !0, get: e[n] });
            }),
            (r.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
            (r.r = (t) => {
                "undefined" != typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
                Object.defineProperty(t, "__esModule", { value: !0 });
            }),
            r((r.s = 227))
        );
    })();
});
